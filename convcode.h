/**
 * @brief A k/n convolutional code implementaion with a fano decoding algorithm.
 *
 * @date 2013.07.13
 * @author Pan Chenglong
 *
 **/

#ifndef CONVCODE_H
#define CONVCODE_H

// Some problem occured when only include the <itpp/itcomm.h> in my machine,
// So in case of convenience, I just include them all exclude the error-complainted one.
#include <itpp/itsignal.h>
#include <itpp/comm/bch.h>
#include <itpp/comm/channel.h>
#include <itpp/comm/channel_code.h>
#include <itpp/comm/commfunc.h>
#include <itpp/comm/convcode.h>
#include <itpp/comm/crc.h>
#include <itpp/comm/egolay.h>
#include <itpp/comm/error_counters.h>
#include <itpp/comm/galois.h>
#include <itpp/comm/hammcode.h>
#include <itpp/comm/interleave.h>
#include <itpp/comm/ldpc.h>
#include <itpp/comm/llr.h>
#include <itpp/comm/modulator.h>
#include <itpp/comm/modulator_nd.h>
#include <itpp/comm/ofdm.h>
#include <itpp/comm/pulse_shape.h>
#include <itpp/comm/rec_syst_conv_code.h>
#include <itpp/comm/reedsolomon.h>
#include <itpp/comm/sequence.h>
#include <itpp/comm/spread.h>
#include <itpp/comm/turbo.h>
#include <itpp/comm/siso.h>
#include <itpp/comm/exit.h>
#include <itpp/comm/stc.h>
#include <cmath>

namespace ratelesscode
{

enum
{
    PRINT_OUTPUT_TABLE = 0x1,
    PRINT_NEXT_STATE_TABLE = 0x2,
    PRINT_METRICS = 0x4,
    PRINT_NODES_CONTENT = 0x8,
    PRINT_TABLES = PRINT_OUTPUT_TABLE | PRINT_NEXT_STATE_TABLE,
    PRINT_ALL =  PRINT_OUTPUT_TABLE | PRINT_NEXT_STATE_TABLE | PRINT_METRICS | PRINT_NODES_CONTENT
};

// node structure for fano decoding
struct node
{
    int state;
    long gamma;
    std::vector<long> metrics;
    std::vector<std::pair<long, unsigned int>> tm;
    int branch;

    // for debug
    bool explored;
};

/**
 * @brief This is a k/n rate convolutional code, with a fano decoding algorithm.
 * Thus this is quite different from the corresponding implementaion built in it++.
 **/
class ConvolutionalCode
{
public:
    ConvolutionalCode(const itpp::ivec& m, const itpp::imat& g_matrix)
       : memory(m), gen_matrix(g_matrix), amp(1.0), noise(std::sqrt(0.05)), scale(4),debug(0)
    {
        k = gen_matrix.rows();
        n = gen_matrix.cols();
        rate = static_cast<double>(k) / n;
        bias = rate;
        init_code();
    }
    ~ConvolutionalCode() { };

    /**
     * @brief encode: a bvec of input
     *
     * @param uncoded_bits: a bvec of uncoded input bits
     * @param coded_bits: the returing coded bits
     * @param tail: whether add padding zeroes in the uncoded bits
     * @return void
     **/
    void encode(const itpp::bvec& uncoded_bits, itpp::bvec& coded_bits, bool tail = true);


    /**
     * @brief decode a vec of received data using soft decision, fano decoding algorithm is used.
     *
     * @param received_signal: a vec of received signal
     * @param decoded_bits: the decoded message bits
     * @param tail: whether encoder has added padding zeroes
     * @return int
     **/
    int decode(const itpp::vec& received_signal, itpp::bvec& decoded_bits,
               int delta, unsigned long max_cycles, bool tail = true);

    /**
     * @brief decode a vec of received data using soft decision
     *
     * @param received_signal: received signal in vec
     * @param tail: whether encoder has added padding zeroes
     * @return :bvec
     **/


    /**
     * @brief get the code rate
     *
     * @return double
     **/
    double get_rate() { return rate; }

    /**
     * set the infomation that the decoder needed. 
     * @param amp 
     * @param noise 
     * @param bias 
     * @param scale 
     * @param debug: debug infomation, control what to print out 
     */
    void set_decoder_env(int amp, double noise, double bias, int scale, int debug);

private:
    // Init the internal structure for the encoder and the decoder.
    void init_code();

    // Split the state to the k register number according to the memory.
    void state_to_regs(int state, itpp::ivec& regs);

    // Combine the serval register numbers into a state according to memory.
    void regs_to_state(const itpp::ivec& regs, int& state);

    // Append the input bit in the leftmost of the shift register.
    void append_input(int input, itpp::ivec& regs);

    // Return the next state
    int next_state(itpp::ivec& regs);

    // Retrieve the metric upon the received symbol.
    long get_metric(int snd, double received);


    // Print current running status, esp. nodes info
    void print_nodes_status(std::vector<node>& nodes);

    // Size of the smallest block of input that can be encoded using the convolutional code.
    int k;

    // Size of the smallest block of output bits generated by the convolutional code.
    int n;

    // Rate of the convolutional code.
    double rate;

    // Number of memory elements per input of the convolutional encoder.
    // The size of this vec is k.
    itpp::ivec memory;

    // Generator matrix G(D) of the convolutional encoder. Each element of
    // G(D) represents a polynomial. This is a k * n matrix.
    itpp::imat gen_matrix;

    // Next state table.
    itpp::imat next_state_table;

    // Ouput bits table.
    itpp::imat output_table;

    // Metrics table with 128 offset. TODO to be modified
    itpp::imat metric_table;

    // Sqrt(Eb)
    int amp;

    // Sqrt(N0/2), standard deviation
    double noise;

    // Bias, most often the Code Rate
    double bias; 

    // Scale the metrics to "integers"
    int scale;

    // Control what to print out.
    int debug;

};

// Convert bvec to an integer
int bvec2int(const itpp::bvec& b, int start, int len);

itpp::bvec int2bvec(int number, int len);

int hamming_weight(int length, int in);


#define M_SQRT2PI 2.5066282746310004535
inline double normal_distribution(double mean, double stddev, double x)
{
    return std::exp(-(x-mean)*(x-mean)/(2 * stddev * stddev))/(M_SQRT2PI * stddev);
}

} // namespace ratelesscode

#endif // #ifndef CONVCODE_H
